//! This library read a file at the given path and try to interpret it as a valid _MSN Messenger_ /
//! _Windows Live Messenger_ conversation archive.
//!
//! If it is a valid archive, it returns an iterator to read the various messages contained in the
//!archive.
//!
//! Archives generated by the _Messenger Plus!_ plugin are supported too.
//!
//! # Exemple
//!```
//! use lib_messenger_archive::{Parser, FileType, MessengerArchive, Message, Data, Text};
//!
//! let mut parser = Parser::new("test/alice1234.xml").unwrap();
//! let expected =  Message {
//!                 datetime: "2009-04-06T19:40:41.851Z".to_string(),
//!                 timezone_offset: Some(120),
//!                 session_id: "1".to_string(),
//!                 sender_friendly_name: "Alice".to_string(),
//!                 receiver_friendly_name: "Bob".to_string(),
//!                 data: vec![Data::Text(Text {
//!                     style: "font-family:Courier New; color:#004000; ".to_string(),
//!                     content: "Hello!".to_string(),
//!                 })],
//!             };
//! assert_eq!(parser.next().unwrap().unwrap(), expected);
//! ```
mod messenger;

use std::error;
pub use crate::messenger::{ArchiveDetails, Message, MessengerArchive};
pub use crate::messenger::{FileType, Data, Text, Image};


type IteratorItem = Result<Message, Box<dyn error::Error>>;

/// This structure automatically handle the various archives types, based on their extensions and
/// call the appropriate parser (Classic XML archive parser or Messenger Plus! parser).
pub struct Parser<'a> {
    parser: Box<dyn MessengerArchive<Item=IteratorItem> + 'a>,
}

impl<'a> Parser<'a> {
    
    /// Generates a new parser for the given file at `path`.
    /// It may return an error if the file cannot be read.
    pub fn new(path: &'a str) -> Result<Self, Box<dyn error::Error>> {
        Ok(Parser {
            parser: Self::get_parser(path)?,
        })
    }

    fn get_parser(path: &str) -> Result<Box<dyn MessengerArchive<Item=IteratorItem> + '_>, Box<dyn error::Error>> {
        if path.ends_with(".xml") {
            Ok(Box::new(messenger::xml_parser::XmlParser::new(path)?))
        }  else {
            Ok(Box::new(messenger::messenger_plus_parser::MessengerPlusParser::new(path)?))
        }
    }
}

impl<'a> Iterator for Parser<'a> {
    /// Each iteration may return an `Error` if something wrong happen or the next `Message`.
    type Item = IteratorItem;

    /// Iterate through the messages in the archive.
    fn next(&mut self) -> Option<Self::Item> {
        self.parser.next()
    }
}

/// Return some global details of the archive. This function must be called after the file was 
/// entirely read through the iterator, otherwise it will return `None`
impl<'a> MessengerArchive for Parser<'a> {
    fn details(&self) -> Option<&ArchiveDetails> {
        self.parser.details()
    }
}

#[cfg(test)]
mod tests {
    use crate::messenger::FileType;
    use super::*;

    #[test]
    fn cannot_parse_file_doesnt_exists() {
        let parser = Parser::new("archive.zip");
        assert!(parser.is_err());
    }
    
    #[test]
    fn parse_sample_file() {
        let mut parser = Parser::new("test/alice1234.xml").unwrap();
        parser.next();
        parser.next();
        assert!(parser.next().is_none());
        assert_eq!(parser.details().unwrap().file_type, FileType::XML);
        assert_eq!(parser.details().unwrap().recipient_id, "alice1234");
    }
    
    #[test]
    fn display_messages() {
        let file = "test/alice1234.xml";
        let mut parser = Parser::new(file).expect("unable to read the archive");
        println!("Messages in archive \"{}\":\n---", file);
        while let Some(message) = parser.next() {
            if let Ok(msg) = message {
                let msg_txts: Vec<&str> = msg.data
                    .iter()
                    .filter_map(|d| match d {
                        Data::Text(txt) => Some(txt.content.as_str()),
                        _ => None,
                    })
                    .collect();
                println!("{}: {}", msg.sender_friendly_name, msg_txts.join(""));
            }
        }
        let details = parser.details().unwrap();
        println!("---\nThose messages were exchanged with: {}", details.recipient_id);
    }
}
