mod messenger;

use crate::messenger::{ArchiveDetails, Message, MessengerArchive};

pub struct Parser<'a> {
    parser: Box<dyn MessengerArchive<Item=Message> + 'a>,
}


/// Read the file at the given path and try to interpret it as a valid MSN Messenger / WLM
/// conversation archive.
///
/// Archives generated by the Messenger Plus! plugin are supported too.
impl<'a> Parser<'a> {
    /// Generates a new parser for the given file at `path`
    pub fn new(path: &'a str) -> Self {
        Parser {
            parser: Self::get_parser(path),
        }
    }

    fn get_parser(path: &str) -> Box<dyn MessengerArchive<Item=Message> + '_> {
        if path.ends_with(".xml") {
            Box::new(messenger::xml_parser::XmlParser::new(path))
        }  else {
            Box::new(messenger::messenger_plus_parser::MessengerPlusParser::new(path))
        }
    }
}

impl<'a> Iterator for Parser<'a> {
    type Item = Message;

    /// Iterate through the messages in the archive
    fn next(&mut self) -> Option<Self::Item> {
        self.parser.next()
    }
}

/// Return some global details of the archive. This function must be called after the file was 
/// entirely read through the iterator.
impl<'a> MessengerArchive for Parser<'a> {
    fn details(&self) -> &ArchiveDetails {
        self.parser.details()
    }
}

#[cfg(test)]
mod tests {
    use crate::messenger::FileType;
    use super::*;

    #[test]
    fn cannot_parse_file_doesnt_exists() {
        let mut parser = Parser::new("archive.zip");
        assert_eq!(parser.next(), None);
        // assert!(result.is_err());
    }
    
    #[test]
    fn parse_sample_file() {
        let mut parser = Parser::new("test/alice1234.xml");
        parser.next();
        parser.next();
        assert_eq!(parser.next(), None);
        assert_eq!(parser.details().file_type, FileType::XML);
        assert_eq!(parser.details().recipient_id, "alice1234");
    }
}
